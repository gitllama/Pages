<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Table_RealTimeRender</title>
</head>
<script src="https://unpkg.com/react@15.6.1/dist/react.min.js"></script>
<script src="https://unpkg.com/react-dom@15.6.1/dist/react-dom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.38/browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-bootstrap/0.31.2/react-bootstrap.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/3.4.2/js-yaml.min.js"></script>
<script src="https://cdn.jsdelivr.net/jsbarcode/3.5.8/barcodes/JsBarcode.code128.min.js"></script>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css">
<style type="text/css">
@page {
  size: A4;
  margin: 0;
}
@media print {
  body {
    width: 210mm; /* needed for Chrome */
    height: 296mm; /* 1mm�]�T���������� */
  }
  #nonprint {
    display: none;
  }
}
</style>

<body>
  <div id="app"></div>
  <script type="text/babel">

  const logo = "";
  const value = JSON.stringify(
  {
    size : 200,
    MaxNumOfShots : {X: 10,Y:7},
    SizeOfShot : {X:17.2,Y:24.8},
    chips : 54,
    notch : 90,
    edgecut : 5,
    notchcut: 9,
    width : 500
  });

  let {
    Button,FormGroup,FormControl,
    PageHeader, FieldGroup,
    Grid, Row, Col, Jumbotron, Table,
    Panel, Label, Alert
  } = window.ReactBootstrap;


  /*Input*/

  class InputApp extends React.Component {
    constructor(props) {
      super(props);
    }
    propTypes: {
      onChange: React.PropTypes.func.isRequired
    }
    onChange(){
      try{
        let dst_yaml = jsyaml.load(ReactDOM.findDOMNode(this.refs.inputText).value);
        let dst = JSON.stringify(dst_yaml);
        this.props.onChange({
          value : dst
        });
      }
      catch(e){
        this.props.onChange({
          value : null
        });
      }
    }
    render() {
      return (
        <Jumbotron style={{padding:"15px"}}>
          <h3>Edit Yaml</h3>
          <FormGroup controlId="formControlsTextarea">
            <FormControl componentClass="textarea"
                         placeholder="textarea"
                         ref="inputText"
                         style={{height:"400px"}}
                         defaultValue={this.props.defaultValue}
                         onChange={this.onChange.bind(this)}/>
            </FormGroup>
        </Jumbotron>
      );
    }
  }


  /*Output*/

  class Wfmap extends React.Component {
    constructor(props) {
      super(props);
      this.margin = 1;
      this.state={
          r : 200,
          MaxNumOfShots : {X:1,Y:1},
          SizeOfShot : {X:1,Y:1},
          notch : 90,
          edgecut : 3,
          notchcut : 9,
          viewbox : "0 0 10 10",
          width : 500
      };
    }
    componentWillReceiveProps(nextProps) {
      /*
      rot = 0
      if notch == "right" :
          rot = 0
      elif notch == "back":
          rot = 270
      elif notch == "left":
          rot = 180
      else:
          rot = 90
          */
      try{
        let hoge = JSON.parse(nextProps.src);

        var w = hoge.SizeOfShot.X * (hoge.MaxNumOfShots.X + 4);
        var h = hoge.SizeOfShot.Y * (hoge.MaxNumOfShots.Y + 4);
        this.setState({
            r : hoge.size,
            MaxNumOfShots : hoge.MaxNumOfShots,
            SizeOfShot : hoge.SizeOfShot,
            notch : hoge.notch,
            edgecut : hoge.edgecut,
            notchcut : hoge.notchcut,
            viewbox : `0 0 ${w} ${h}`,
            width : hoge.width
        });
      }catch(e){
        console.log(e);
      }
    }
    drawBackGround(){
      let hoge = [];
      let xs = this.state.SizeOfShot.X,
          ys = this.state.SizeOfShot.Y,
          x  = this.state.MaxNumOfShots.X,
          y  = this.state.MaxNumOfShots.Y;

      for(let i = 1; i < (x + 2) - 1; i++){
        hoge.push({x1 : xs + i * xs, y1 : ys, x2: xs + i * xs, y2 : ys + (y + 1) * ys });
      }
      for(let i = 1;i < (y + 2) - 1; i++){
        hoge.push({x1 : xs, y1 : ys + i * ys, x2 : xs + (x + 1) * xs, y2 : ys + i * ys });
      }
      let lines = hoge.map((i)=><line x1={i.x1} y1={i.y1} x2={i.x2} y2={i.y2} stroke="lightgray" stroke-width="1" />);
      return(
        <g>
          {lines}
          <rect x={xs} y={ys} width={xs + (x+1)*xs} height={ys + (y+1)*ys}
                stroke="black" fill="none" stroke-width="2" />
        </g>
      );
    }
    drawWfNotch(){
      var hoge;
      let radian =(deg)=> deg * Math.PI / 180;
      let degree =(rad)=> rad * 180 / Math.PI;
      let x = (this.state.MaxNumOfShots.X + 4) * this.state.SizeOfShot.X/2,
          y = (this.state.MaxNumOfShots.Y + 4) * this.state.SizeOfShot.Y/2,

          r = this.state.r,
          rot = this.state.notch,
          notchcut = this.state.notchcut,
          cutsize = this.state.edgecut/2,
          rot_o = degree(Math.asin(cutsize * 2 / (r/2)));

      let cx_s = x + r/2 * Math.cos(radian(rot - rot_o)),
          cy_s = y + r/2 * Math.sin(radian(rot - rot_o)),
          cx_e = x + r/2 * Math.cos(radian(rot + rot_o)),
          cy_e = y + r/2 * Math.sin(radian(rot + rot_o)),
          nx = x + (r/2 - cutsize) * Math.cos(radian(rot)),
          ny = y + (r/2 - cutsize) * Math.sin(radian(rot));
      let str = `M ${cx_s} ${cy_s} A ${r/2} ${r/2} ${rot - rot_o} 1 0 ${cx_e}, ${cy_e} L ${nx}, ${ny} z`;

      let cx_si = x + (r/2 - notchcut) * Math.cos(radian(rot)) - r/3 * Math.sin(radian(rot)),
      cy_si = y + (r/2 - notchcut) * Math.sin(radian(rot)) - r/3 * Math.cos(radian(rot)),
      cx_ei = x + (r/2 - notchcut) * Math.cos(radian(rot)) + r/3 * Math.sin(radian(rot)),
      cy_ei = y + (r/2 - notchcut) * Math.sin(radian(rot)) + r/3 * Math.cos(radian(rot))

       //notch -> Edge -> Notch Reserved Distance
       return(
         <g>
           <path d ={str} stroke="black" fill="none" stroke-width="2" />
           <circle cx={x} cy={y} r={r/2- cutsize*2}
                   stroke="black" fill="none" stroke-width="2" />
           <line x2={cx_si} y1={cy_si} x1={cx_ei} y2={cy_ei} stroke="black" stroke-width="1" />
         </g>
       );
    }

    drawText(){
      let hoge = [];
      let txtoffset =9 / 2;
      for(let i = 2;i < this.state.x-2; i++){
        hoge.push({x : i*this.state.xs + this.state.xs/2, y :(this.state.y-1)*this.state.ys + this.state.ys/2 + txtoffset, value:i-1});
      }
      for(let i = 2;i < this.state.y-2; i++){
        hoge.push({x : this.state.xs/2, y : i*this.state.ys + this.state.ys/2 + txtoffset, value:i-1});
      }
      let n = hoge.map((i)=><text x={i.x} y={i.y} textAnchor="middle" fontSize="9">{i.value}</text>);

      return(
        <g>
        <marker id="m_atr" markerUnits="strokeWidth" markerWidth="3" markerHeight="3"
                viewBox="0 0 10 10" refX="5" refY="5" orient="auto-start-reverse">
          <polygon points="0,0 5,5 0,10 10,5" fill="red"/>
        </marker>
          {n}
          <text x={(this.state.x - 0.8)*this.state.xs} y={ this.state.y*this.state.ys/2} font-size="6">X</text>
          <line x1={this.state.xs * 0.8} y1={this.state.y*this.state.ys/2}
                x2={(this.state.x - 0.8)*this.state.xs} y2={this.state.y*this.state.ys/2}
                stroke="red" strokeWidth="2" markerEnd="url(#m_atr)" />

          <text x={this.state.x*this.state.xs/2} y={this.state.ys * 0.8} font-size="6">Y</text>
          <line x1={this.state.x*this.state.xs/2} y1={this.state.ys * 0.8}
                x2={this.state.x*this.state.xs/2} y2={(this.state.y - 0.8)*this.state.ys}
                stroke="red" strokeWidth="2" markerEnd="url(#m_atr)" />
        </g>
      );
    }

    drawValue(){
      let hoge = [];
      let txtoffset = 9 / 2;
      for(let y = 2;y < this.state.y-2; y++){
        for(let x = 2;x < this.state.x-2; x++){
          hoge.push({
            x     : x*this.state.xs + this.state.xs/2,
            y     : y*this.state.ys + this.state.ys/2 + txtoffset,
            value : `${x}-${y}`
          });
        }
      }
      let n = hoge.map((i)=><text x={i.x} y={i.y} textAnchor="middle" fontSize="9">{i.value}</text>);

      return(
        <g>
          {n}
        </g>
      );
    }
    render() {
      return (
        <svg viewBox={this.state.viewbox} width={this.state.width}>
          {this.drawBackGround()}
          {this.drawWfNotch()}
        </svg>
      );
    }
  }
/*


{this.drawText()}
{this.drawValue()}

*/

  /*App*/

  class App extends React.Component {
    constructor(props) {
      super(props);
      this.state={
        value : null
      };
    }
    componentDidMount(){
      this.setState({value : value});
    }
    onChange(e){
      this.setState({value : e.value});
    }
    render() {
      return (
        <div>
          <div id="nonprint" style={{padding:'20px'}}>
            <InputApp defaultValue={jsyaml.dump(JSON.parse(value))}
                    onChange={this.onChange.bind(this)} />
            <h3>View</h3>
          </div>
          <section style={{pageBreakAfter : 'always'}}>
            <Wfmap src={this.state.value}/>
          </section>
        </div>
      );
    }
  }

  ReactDOM.render(<App />, document.querySelector('#app'));

  </script>
</body>
</html>
